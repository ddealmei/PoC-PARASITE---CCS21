# Proof of Concept attack on SRP

This repository contains a proof of concept of an attack on OpenSSL's implementation of SRP, allowing an attacker to recover the password using an offline dictionary attack, exploiting some data leaked through a side channel during an insecure modular exponentiation.

## Repository layout

* PoC_material/ contains all material to be used to build the docker
* shared_folder/ will be shared between the docker and the host, making it easier to transmit files. Namely, it contains a sample of the data we were able to extract during our experiment.

## Core idea of the attack

During the *Key commitment* part of SRP, the client computes the verifier *v = g^x mod p*, where *x* is directly related to the password (`x = H(salt, H(id:pwd))`). This operation is performed in `SRP_Calc_client_key_ex`, through a call to `BN_mod_exp`.

Due to a lack of constant-time flags and the use of small base in SRP, the modular exponentiation method `BN_mod_exp` calls `BN_mod_exp_mont_word`.

This quick exponentiation relies on Montgomery exponentiation, using a square and multiply approach. A word `w` is used as an accumulator to perform quick operation until it overflows. 
When it first overflow, a variable is set to store the result in Montgomery form, which is then squared (using the Montgomery squaring) at each iteration, and updated whenever the word accumulator overflows.

Since the execution flow of this function vary along with the value of the exponent, an attacker is able to recover information on the binary value of the exponent, breaking the security of SRP.

## Threat model

To exploit it, the attackers need to be able to monitor the CPU cache, using a classical Flush+Reload attack for instance. To do so, we assume the attackers are able to deploy a spy process, with no specific privileges other than being able to read the OpenSSL dynamic library (which is a default permissions).

We assume OpenSSL to be built with a default configuration, meaning compiler optimization are enabled, and debugging mode is disabled.

This spy process is assumed to run in background in order to record the CPU cache access to some specific functions.

## Run the PoC

We provide a docker to avoid any compatibility issue. However, it is worth noting that the nature of our attack (cache side-channels) makes the exact outcome of the spy process dependent of the executing CPU, which might lead to less reliable results. We included a sample of our results in shared_folder/traces. 

First, build the docker, which may take some times (longest part of our PoC):
```
docker build --rm -t poc_openssl_srp .
```
Once the build is done, you can simply run it:
```
docker run --mount type=bind,source="$(pwd)"/shared_folder,target=/PoC_SRP/shared_folder -it poc_openssl_srp
```

Inside the docker, you may run the following command to reproduce our results:
```bash
# Launch the SRP simulation along with the spy process to acquire some traces
./poc.sh -p superpassword
# Interpret the execution trace generated by the spy process to extract information
trace_parser.py traces_admin_superpassword_0102030405060708/* > infos_admin_superpassword_0102030405060708.txt
# Given the extracted information, compute a matching score for all passwords in the dictionary. The lower the score, the higher the chance we found the correct password
for info in $(cat infos_admin_superpassword_0102030405060708.txt | grep -v "Error");
do
    dict_reducer /usr/share/dict/rockyou.txt $info
done
```

As mentioned above, the first step may be an issue on different CPU, so you may need to run the parsing and reduction on the data we provide to get reliable results.
To do so, simply run:
```bash
trace_parser.py shared_folder/traces/traces_admin_dAdinretAm_0102030405060708/* > infos_admin_dAdinretAm_0102030405060708.txt
for info in $(cat infos_admin_dAdinretAm_0102030405060708.txt | grep -v "Error");
do
    dict_reducer /usr/share/dict/rockyou.txt $info
done
```
